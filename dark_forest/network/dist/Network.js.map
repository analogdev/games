{"version":3,"file":"Network.js","sourceRoot":"","sources":["../src/Network.ts"],"names":[],"mappings":"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","sourcesContent":["import { DEFAULT_MAX_CALL_RETRIES } from '@darkforest_eth/constants';\nimport { address } from '@darkforest_eth/serde';\nimport { AutoGasSetting, EthAddress, GasPrices, SignedMessage } from '@darkforest_eth/types';\nimport { BigNumber, Contract, ContractInterface, providers, utils, Wallet } from 'ethers';\nimport stringify from 'json-stable-stringify';\nimport retry from 'p-retry';\nimport timeout from 'p-timeout';\n\nexport type RetryErrorHandler = (i: number, e: Error) => void;\n\n/**\n * Calls the given function, retrying it if there is an error.\n *\n * @todo Get rid of this, and make use of {@link ContractCaller}.\n */\nexport const callWithRetry = async <T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  fn: (...args: any[]) => Promise<T>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: any[] = [],\n  onError?: RetryErrorHandler,\n  maxRetries = DEFAULT_MAX_CALL_RETRIES,\n  retryInterval = 1000\n): Promise<T> => {\n  return retry(() => fn(...args), {\n    // TODO: Should we set maxRetryTime?\n    retries: maxRetries,\n    minTimeout: retryInterval,\n    maxTimeout: 60_000,\n    onFailedAttempt(e) {\n      console.error(`error: ${e}`);\n      console.log(`retrying (${e.attemptNumber + 1}/${maxRetries})...`);\n      if (onError) {\n        try {\n          onError(e.attemptNumber, e);\n        } catch (e) {\n          console.log(`failed executing callWithRetry error handler`, e);\n        }\n      }\n    },\n  });\n};\n\n/**\n * Given the user's auto gas setting, and the current set of gas prices on the network, returns the\n * preferred gas price. If an invalid {@link AutoGasSetting} is provided, then returns undefined.\n */\nexport function getGasSettingGwei(\n  setting: AutoGasSetting,\n  gasPrices: GasPrices\n): number | undefined {\n  switch (setting) {\n    case AutoGasSetting.Slow:\n      return gasPrices.slow;\n    case AutoGasSetting.Average:\n      return gasPrices.average;\n    case AutoGasSetting.Fast:\n      return gasPrices.fast;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * A function that just never resolves.s\n */\nexport function neverResolves(): Promise<void> {\n  return new Promise(() => {});\n}\n\n/**\n * A useful utility function that breaks up the proverbial number line (defined by {@code total} and\n * {@code querySize}), and calls {@code getterFn} for each of the sections on the number line.\n *\n * @param total the total amount of of items to get\n * @param querySize the chunk size\n * @param getterFn a function that fetches something, given a start index and end index\n * @param onProgress whenever a chunk is loaded, this function is called with the fraction of\n * individual items that have been loaded so far.\n * @param offset the index to start fetching, can be used to skip previously fetched elements.\n * @returns a list of each of the individual items that were loaded.\n */\nexport const aggregateBulkGetter = async <T>(\n  total: number,\n  querySize: number,\n  getterFn: (startIdx: number, endIdx: number) => Promise<T[]>,\n  // the parameter to this function is a value between 0 and 1. We guarantee at least one call to\n  // `onProgress` if you provide it. The guaranteed call is the one at the end, where the value is 1.\n  onProgress?: (fractionCompleted: number) => void,\n  offset = 0\n): Promise<T[]> => {\n  const promises: Promise<T[]>[] = [];\n  let loadedSoFar = 0;\n\n  for (let page = 0; page * querySize + offset < total; page += 1) {\n    const start = page * querySize + offset;\n    const end = Math.min((page + 1) * querySize + offset, total);\n    const loadedThisBatch = end - start;\n    promises.push(\n      new Promise<T[]>(async (resolve) => {\n        let res: T[] = [];\n        while (res.length === 0) {\n          res = await getterFn(start, end);\n          loadedSoFar += loadedThisBatch;\n          onProgress && onProgress(loadedSoFar / total);\n        }\n\n        resolve(res);\n      })\n    );\n  }\n\n  const unflattenedResults = await Promise.all(promises);\n\n  onProgress && onProgress(1);\n\n  return unflattenedResults.flat();\n};\n\n/**\n * Given a transaction hash and a JsonRpcProvider, waits for the given transaction to complete.\n */\nexport function waitForTransaction(\n  provider: providers.JsonRpcProvider,\n  txHash: string\n): Promise<providers.TransactionReceipt> {\n  return retry(\n    async (tries) => {\n      console.log(`[wait-tx] WAITING ON tx hash: ${txHash} tries ${tries}`);\n\n      try {\n        const receipt = await timeout(provider.getTransactionReceipt(txHash), 30 * 1000);\n\n        if (receipt) {\n          console.log(`[wait-tx] FINISHED tx hash: ${txHash} tries ${tries}`);\n          return receipt;\n        } else {\n          return Promise.reject(new Error(\"couldn't get receipt\"));\n        }\n      } catch (e) {\n        console.error(`[wait-tx] TIMED OUT tx hash: ${txHash} tries ${tries} error:`, e);\n        return Promise.reject(e);\n      }\n    },\n    {\n      // TODO: Should we set maxRetryTime?\n      retries: DEFAULT_MAX_CALL_RETRIES,\n      minTimeout: 2000,\n      maxTimeout: 60_000,\n      factor: 1.5,\n      onFailedAttempt(e) {\n        console.log(`[wait-tx] SLEEPING tx hash: ${txHash} tries ${e.attemptNumber} sleeping...`);\n      },\n    }\n  );\n}\n\n/**\n * @param contractAddress the address of the contract you want to connect to\n * @param contractABI a javacript object representing the ABI\n */\nexport function createContract<C extends Contract>(\n  contractAddress: string,\n  contractABI: ContractInterface,\n  provider: providers.JsonRpcProvider,\n  signer?: Wallet\n): C {\n  return new Contract(contractAddress, contractABI, signer ?? provider) as C;\n}\n\n/**\n * Creates a new {@link JsonRpcProvider}, and makes sure that it's connected to xDai if we're in\n * production.\n */\nexport function makeProvider(rpcUrl: string): providers.JsonRpcProvider {\n  let provider;\n\n  if (rpcUrl.startsWith('wss://')) {\n    provider = new providers.WebSocketProvider(rpcUrl);\n  } else {\n    provider = new providers.StaticJsonRpcProvider(rpcUrl);\n    provider.pollingInterval = 8000;\n  }\n\n  return provider;\n}\n\n/**\n * Ensures that the given message was properly signed.\n */\nexport function assertProperlySigned(message: SignedMessage<unknown>): void {\n  const preSigned = stringify(message.message);\n\n  if (!verifySignature(preSigned, message.signature as string, message.sender)) {\n    throw new Error(`failed to verify: ${message}`);\n  }\n}\n\n/**\n * Returns whether or not the given message was signed by the given address.\n */\nexport function verifySignature(\n  message: string,\n  signature: string,\n  addr: EthAddress | undefined\n): boolean {\n  if (!addr) {\n    return false;\n  }\n  return address(utils.verifyMessage(message, signature)) === addr;\n}\n\n/**\n * Returns the given amount of gwei in wei as a big integer.\n */\nexport function gweiToWei(gwei: number): BigNumber {\n  return utils.parseUnits(gwei + '', 'gwei');\n}\n\n/**\n * Returns the given amount of wei in gwei as a number.\n */\nexport function weiToGwei(wei: BigNumber): number {\n  return parseFloat(utils.formatUnits(wei, 'gwei'));\n}\n\n/**\n * Returns the given amount of wei in gwei as a number.\n */\nexport function weiToEth(wei: BigNumber): number {\n  return parseFloat(utils.formatEther(wei));\n}\n\n/**\n * Returns the given amount of eth in wei as a big integer.\n */\nexport function ethToWei(eth: number): BigNumber {\n  return utils.parseEther(eth + '');\n}\n\n/**\n * Whether or not some value is being transferred in this transaction.\n */\nexport function isPurchase(tx?: providers.TransactionRequest): boolean {\n  return tx !== undefined && tx.value !== undefined && tx.value > 0;\n}\n"]}