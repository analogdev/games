{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;AA0BA,8DAAiC;AAEjC;;;;;;GAMG;AACH,SAAgB,eAAe,CAAC,MAAc,EAAE,SAAiB,EAAE,OAAe;IAChF,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,GAAG,SAAS,EAAE,CAAC,GAAG,OAAO,CAAC,CAAC;IAChE,OAAO,IAAA,qBAAM,EAAC,KAAK,UAAU,EAAE,CAAC,CAAC;AACnC,CAAC;AAHD,0CAGC;AAED,wEAAwE;AACxE,MAAM,SAAS,GAAG,IAAI,GAAG,EAA2B,CAAC;AAErD;;;;GAIG;AACH,SAAgB,YAAY,CAAC,GAAe;IAC1C,MAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACjC,IAAI,KAAK;QAAE,OAAO,KAAK,CAAC;IAExB,MAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAgB,CAAC;IAErD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACxC,QAAQ,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;KAC9D;IAED,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;IAC7B,OAAO,QAAQ,CAAC;AAClB,CAAC;AAZD,oCAYC;AAED;;;;GAIG;AACH,SAAgB,cAAc,CAAC,MAAe;IAC5C,IAAI,CAAC,MAAM;QAAE,OAAO,KAAK,CAAC;IAC1B,OAAO,YAAY,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC;AAChE,CAAC;AAHD,wCAGC","sourcesContent":["/**\n * This package contains functions for determining various properties of Dark Forest objects based on their ID in hex. You could think of this package like procedural generation for Ethereum addresses.\n *\n * **Note:** This package _might_ go away when objects become classes that contain a lot of these helpers as instance methods.\n *\n * ## Installation\n *\n * You can install this package using [`npm`](https://www.npmjs.com) or\n * [`yarn`](https://classic.yarnpkg.com/lang/en/) by running:\n *\n * ```bash\n * npm install --save @darkforest_eth/hexgen\n * ```\n * ```bash\n * yarn add @darkforest_eth/hexgen\n * ```\n *\n * When using this in a plugin, you might want to load it with [skypack](https://www.skypack.dev)\n *\n * ```js\n * import * as hexgen from 'http://cdn.skypack.dev/@darkforest_eth/hexgen'\n * ```\n *\n * @packageDocumentation\n */\nimport type { LocationId, Planet, PlanetBonus } from '@darkforest_eth/types';\nimport bigInt from 'big-integer';\n\n/**\n * The core method for extracting planet details from a LocationID.\n *\n * @param hexStr LocationID of a planet.\n * @param startByte The first byte to include in the result.\n * @param endByte The byte _after_ the last byte to include in the result.\n */\nexport function getBytesFromHex(hexStr: string, startByte: number, endByte: number) {\n  const byteString = hexStr.substring(2 * startByte, 2 * endByte);\n  return bigInt(`0x${byteString}`);\n}\n\n// This is a cache of bonuses by LocationID to avoid an expensive recalc\nconst bonusById = new Map<LocationId, PlanetBonus>();\n\n/**\n * Extracts the bonuses of a planet given its LocationID.\n *\n * @param hex LocationID of a planet.\n */\nexport function bonusFromHex(hex: LocationId): PlanetBonus {\n  const bonus = bonusById.get(hex);\n  if (bonus) return bonus;\n\n  const newBonus = Array(6).fill(false) as PlanetBonus;\n\n  for (let i = 0; i < newBonus.length; i++) {\n    newBonus[i] = getBytesFromHex(hex, 9 + i, 10 + i).lesser(16);\n  }\n\n  bonusById.set(hex, newBonus);\n  return newBonus;\n}\n\n/**\n * Checks if the LocationID of the planet indicates any bonuses.\n *\n * @param planet Planet to check for bonuses.\n */\nexport function planetHasBonus(planet?: Planet): boolean {\n  if (!planet) return false;\n  return bonusFromHex(planet.locationId).some((bonus) => bonus);\n}\n"]}