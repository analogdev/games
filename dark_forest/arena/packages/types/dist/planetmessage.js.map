{"version":3,"file":"planetmessage.js","sourceRoot":"","sources":["../src/planetmessage.ts"],"names":[],"mappings":";;;AA8BA;;GAEG;AACU,QAAA,iBAAiB,GAAG;IAC/B,SAAS,EAAE,WAAgC;CACnC,CAAC","sourcesContent":["import type { EthAddress, LocationId } from './identifier';\nimport type { Abstract } from './utility';\n\n/**\n * This set of types essentially defines a protocol by which we can add individual `Message`s (which\n * have a `type` and a `sender` and a `timeCreated` and a `body`, where the body can really be\n * anything) to individual planets. A planet can have an unlimited amount of messages of any type.\n * Rate limiting, serializing/deserializing, enforcing ownership requirements, all these things are\n * *not* the responsibility of this message protocol. Use this as a storage mechanism and take care\n * of the buisness logic yourself.\n *\n * Currently there is one type of message that a planet can have: an single emoji 'flag' set by the\n * owner of the planet, which hovers above the planet on everyone's web client.\n *\n * In the future, we might consider building things like:\n * - a comment on a planet. anyone can just post any text comment.\n * - an emoji react to a planet.\n * - an http url set by the owner of the planet\n * - some cosmetic item that we want to give some planets.\n * - a markdown file posted by the owner of the planet.\n *\n * In the future, we might also consider supporting at the very least submitting hashes of these\n * messages on-chain.\n */\n\n/**\n * Abstract type representing a type of planet message.\n */\nexport type PlanetMessageType = Abstract<string, 'PlanetMessageType'>;\n\n/**\n * Each message type has a corresponding entry here.\n */\nexport const PlanetMessageType = {\n  EmojiFlag: 'EmojiFlag' as PlanetMessageType,\n} as const;\n\n/**\n * Owners of planets can post emojis on the planet.\n */\nexport interface EmojiFlagBody {\n  emoji: string;\n}\n\n/**\n * Thinking about future message types.\n */\nexport type PlanetMessageBody = EmojiFlagBody | unknown;\n\n/**\n * We can save these to and retrieve these from the database.\n */\nexport interface PlanetMessage<T extends PlanetMessageBody> {\n  id: string;\n  type: PlanetMessageType;\n  sender: EthAddress;\n  timeCreated: number;\n  planetId: LocationId;\n  body: T;\n}\n\n/**\n * Asks the webserver to get all the the messages posted to some set of planets.\n */\nexport interface PlanetMessageRequest {\n  planets: LocationId[];\n}\n\n/**\n * Contains the answer to the above question.\n */\nexport interface PlanetMessageResponse {\n  [planetId: string /* this is really a LocationId */]: PlanetMessage<unknown>[];\n}\n\n/**\n * Asks the webserver to post an emoji to a particular planet.\n */\nexport interface PostMessageRequest<T extends PlanetMessageBody> {\n  type: PlanetMessageType;\n  locationId: LocationId;\n  body: T;\n}\n\n/**\n * Asks the webserver to delete some messages.\n */\nexport interface DeleteMessagesRequest {\n  locationId: LocationId;\n  ids: string[];\n}\n\n/**\n * A signed message contains some sort of message, as well as its signature and the address that\n * claims to have signed this message.\n */\nexport interface SignedMessage<T> {\n  sender?: EthAddress;\n  signature?: string;\n  message: T;\n}\n"]}