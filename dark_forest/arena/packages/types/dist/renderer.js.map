{"version":3,"file":"renderer.js","sourceRoot":"","sources":["../src/renderer.ts"],"names":[],"mappings":";;;AAoCa,QAAA,UAAU,GAAG;IACxB,KAAK,EAAE,IAAkB;IACzB,KAAK,EAAE,IAAkB,EAAE,4EAA4E;CACxG,CAAC;AAGW,QAAA,QAAQ,GAAG;IACtB,SAAS,EAAE,CAAa;IACxB,KAAK,EAAE,CAAa;IACpB,MAAM,EAAE,CAAa,EAAE,qEAAqE;CAC7F,CAAC;AAUW,QAAA,WAAW,GAAG;IACzB,IAAI,EAAE,CAAgB;IACtB,IAAI,EAAE,CAAgB;IACtB,KAAK,EAAE,CAAgB;IACvB,KAAK,EAAE,CAAgB;IACvB,OAAO,EAAE,CAAgB;IACzB,IAAI,EAAE,CAAgB;CACvB,CAAC;AA2BW,QAAA,SAAS,GAAG;IACvB,IAAI,EAAE,CAAc;IACpB,MAAM,EAAE,GAAgB;IACxB,KAAK,EAAE,CAAc;CACtB,CAAC;AAGW,QAAA,UAAU,GAAG;IACxB,GAAG,EAAE,CAAe;IACpB,MAAM,EAAE,GAAiB;IACzB,MAAM,EAAE,CAAe;CACxB,CAAC;AAGW,QAAA,YAAY,GAAG;IAC1B,UAAU,EAAE,CAAiB;IAC7B,OAAO,EAAE,CAAC,CAAiB;IAC3B,OAAO,EAAE,CAAC,EAAkB;IAC5B,IAAI,EAAE,CAAC,EAAkB;IACzB,EAAE,EAAE,CAAC,EAAkB;IAEvB,OAAO,EAAE,CAAC,EAAkB;IAC5B,GAAG,EAAE,CAAC,EAAkB;CACzB,CAAC;AA6DW,QAAA,YAAY,GAAG;IAC1B,MAAM,EAAE,CAAiB;IACzB,IAAI,EAAE,CAAiB;IACvB,YAAY,EAAE,CAAiB;IAC/B,MAAM,EAAE,CAAiB;IACzB,KAAK,EAAE,CAAiB;IACxB,QAAQ,EAAE,CAAiB;IAC3B,IAAI,EAAE,CAAiB;IACvB,MAAM,EAAE,CAAiB;IACzB,WAAW,EAAE,CAAiB;IAC9B,IAAI,EAAE,CAAiB;IACvB,OAAO,EAAE,EAAkB;IAC3B,QAAQ,EAAE,EAAkB;IAC5B,QAAQ,EAAE,EAAkB;IAC5B,IAAI,EAAE,EAAkB;IACxB,UAAU,EAAE,EAAkB;IAC9B,KAAK,EAAE,EAAkB;IACzB,OAAO,EAAE,EAAkB;IAC3B,MAAM,EAAE,EAAkB;IAC1B,IAAI,EAAE,EAAkB;IACxB,IAAI,EAAE,EAAkB;IACxB,MAAM,EAAE,EAAkB;IAC1B,EAAE,EAAE,EAAkB;IACtB,aAAa,EAAE,EAAkB;IACjC,UAAU,EAAE,EAAkB;IAC9B,SAAS,EAAE,EAAkB;IAC7B,WAAW,EAAE,EAAkB;CAChC,CAAC","sourcesContent":["import type { mat3, mat4 } from 'gl-matrix';\nimport type { RenderedArtifact } from './artifact';\nimport type { HatType } from './hat';\nimport type { LocationId } from './identifier';\nimport type { LocatablePlanet, Planet } from './planet';\nimport type { Abstract } from './utility';\nimport type { Chunk, WorldCoords } from './world';\n\nexport interface PlanetRenderInfo {\n  planet: LocatablePlanet;\n  radii: Radii;\n  blocked: boolean;\n}\n\nexport interface Radii {\n  radiusWorld: number;\n  radiusPixels: number;\n}\n\nexport interface CanvasCoords {\n  x: number;\n  y: number;\n}\n\nexport interface GameViewport {\n  worldToCanvasCoords(worldCoords: WorldCoords): CanvasCoords;\n  worldToCanvasDist(dist: number): number;\n  canvasToWorldCoords(canvasCoord: CanvasCoords): WorldCoords;\n  scale: number;\n  centerWorldCoords: WorldCoords;\n  viewportWidth: number;\n  viewportHeight: number;\n  intersectsViewport(chunk: Chunk): boolean;\n}\n\nexport type AttribType = Abstract<number, 'AttribType'>;\nexport const AttribType = {\n  Float: 5126 as AttribType, // window.WebGL2RenderingContext && WebGL2RenderingContext['FLOAT'],\n  UByte: 5121 as AttribType, // window.WebGL2RenderingContext && WebGL2RenderingContext['UNSIGNED_BYTE'],\n};\n\nexport type DrawMode = Abstract<number, 'DrawMode'>;\nexport const DrawMode = {\n  Triangles: 4 as DrawMode, // window.WebGL2RenderingContext && WebGL2RenderingContext['TRIANGLES'],\n  Lines: 1 as DrawMode, // window.WebGL2RenderingContext && WebGL2RenderingContext['LINES'],\n  Points: 0 as DrawMode, // window.WebGL2RenderingContext && WebGL2RenderingContext['POINTS'],\n};\n\nexport type AttribProps = {\n  dim: number;\n  type: AttribType; // gl.FLOAT, etc\n  normalize: boolean;\n  name: string;\n};\n\nexport type UniformType = Abstract<number, 'UniformType'>;\nexport const UniformType = {\n  Mat4: 0 as UniformType,\n  Mat3: 1 as UniformType,\n  UByte: 2 as UniformType,\n  Float: 3 as UniformType,\n  Texture: 4 as UniformType,\n  Vec3: 5 as UniformType,\n};\n\nexport type Vec3 = [number, number, number];\n\nexport type UniformJSType = mat4 | mat3 | number | Vec3;\n\nexport type UniformProps = {\n  name: string;\n  type: UniformType;\n};\n\nexport type RGBVec = [number, number, number];\n\nexport type RGBAVec = [number, number, number, number];\n\nexport type Translation = {\n  x: number;\n  y: number;\n};\n\nexport type Scaling = {\n  x: number;\n  y: number;\n};\nexport type HSLVec = readonly [number, number, number];\n\nexport type TextAlign = Abstract<number, 'TextAlign'>;\nexport const TextAlign = {\n  Left: 0 as TextAlign,\n  Center: 0.5 as TextAlign,\n  Right: 1 as TextAlign,\n};\n\nexport type TextAnchor = Abstract<number, 'TextAnchor'>;\nexport const TextAnchor = {\n  Top: 0 as TextAnchor,\n  Middle: 0.5 as TextAnchor,\n  Bottom: 1 as TextAnchor,\n};\n\nexport type RenderZIndex = Abstract<number, 'RenderZIndex'>;\nexport const RenderZIndex = {\n  Background: 0 as RenderZIndex,\n  Voyages: -1 as RenderZIndex,\n  Planets: -10 as RenderZIndex,\n  Text: -11 as RenderZIndex,\n  UI: -12 as RenderZIndex,\n\n  DEFAULT: -98 as RenderZIndex,\n  MAX: -99 as RenderZIndex,\n};\n\nexport type RuinsInfo = {\n  [PlanetLevel: number]: {\n    weights: [number, number, number, number];\n    props: [number, number, number, number];\n  };\n};\n\nexport interface PlanetCosmeticInfo {\n  baseHue: number;\n\n  baseStr: string;\n  bgStr: string;\n\n  baseColor: RGBVec;\n  baseColor2: RGBVec;\n  baseColor3: RGBVec;\n\n  mtnColor: RGBVec;\n  mtnColor2: RGBVec;\n  mtnColor3: RGBVec;\n\n  backgroundColor: RGBVec;\n  previewColor: RGBVec;\n\n  landRgb: RGBVec;\n  oceanRgb: RGBVec;\n  beachRgb: RGBVec;\n\n  asteroidHsl: HSLVec;\n\n  seed: number;\n\n  hatType: HatType;\n\n  spacetime1: RGBVec;\n  spacetime2: RGBVec;\n  spacetime3: RGBVec;\n\n  ruins?: RuinsInfo;\n}\n\nexport type SpaceColorConfiguration = {\n  innerNebulaColor?: string;\n  nebulaColor?: string;\n  spaceColor?: string;\n  deepSpaceColor?: string;\n  deadSpaceColor?: string;\n};\n\nexport interface IRendererConfig {\n  spaceColors: SpaceColorConfiguration;\n}\n\n/**\n * Enum for determining the type of renderer\n * Each renderer should contain a variable called 'rendererType'\n * 'rendererType' should be a enum that corresponds with the type of renderer it is\n */\nexport type RendererType = Abstract<number, 'RendererType'>;\nexport const RendererType = {\n  Planet: 0 as RendererType,\n  Mine: 1 as RendererType,\n  SpacetimeRip: 2 as RendererType,\n  Quasar: 3 as RendererType,\n  Ruins: 4 as RendererType,\n  Asteroid: 5 as RendererType,\n  Ring: 6 as RendererType,\n  Sprite: 7 as RendererType,\n  BlackDomain: 8 as RendererType,\n  Text: 9 as RendererType,\n  Voyager: 10 as RendererType,\n  Wormhole: 11 as RendererType,\n  MineBody: 12 as RendererType,\n  Belt: 13 as RendererType,\n  Background: 14 as RendererType,\n  Space: 15 as RendererType,\n  Unmined: 16 as RendererType,\n  Perlin: 17 as RendererType,\n  Line: 18 as RendererType,\n  Rect: 19 as RendererType,\n  Circle: 20 as RendererType,\n  UI: 21 as RendererType,\n  PlanetManager: 22 as RendererType,\n  QuasarBody: 23 as RendererType,\n  QuasarRay: 24 as RendererType,\n  CaptureZone: 25 as RendererType,\n};\n\nexport interface PlanetRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * @param planet - an object that contains info about the planet to be drawn\n   * @param centerW - represents the coordinates of the planet to the game world.\n   * @param radiusW - represents the radius of the planet relative to the game world\n   */\n  queuePlanetBody(planet: Planet, centerW: WorldCoords, radiusW: number): void;\n\n  /**\n   * Draws all queued planets.\n   */\n  flush(): void;\n}\n\nexport interface MineRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * @param planet - an object that contains info about the the Mine/Asteroid Field planet to be drawn\n   * @param centerW - represents the coordinates of the asteroid field relative to the game world.\n   * @param radiusW - represents the radius of the asteroid field relative to the game world\n   */\n  queueMine(planet: Planet, centerW: WorldCoords, radiusW: number): void;\n\n  /**\n   * Draws all queued Asteroid Fields.\n   */\n  flush(): void;\n}\n\nexport interface SpacetimeRipRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * @param planet - an object that contains info about the Spacetime Rip planet to be drawn\n   * @param centerW - represents the coordinates of the Spacetime Rips relative to the game world.\n   * @param radiusW - represents the radius of the Spacetime Rips relative to the game world.\n   */\n  queueRip(planet: Planet, centerW: WorldCoords, radiusW: number): void;\n\n  /**\n   * Draws all queued Spacetime Rips.\n   */\n  flush(): void;\n}\n\nexport interface QuasarRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * @param planet - an object that contains info about the current Quasar planet\n   * @param centerW - represents the coordinates of the current Quasar relative to the game world.\n   * @param radiusW - represents the radius of the Quasar relative to the size of the game world.\n   */\n  queueQuasar(planet: Planet, centerW: WorldCoords, radiusW: number): void;\n\n  /**\n   * Draws all queued Quasars.\n   */\n  flush(): void;\n}\n\nexport interface RuinsRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * @param planet - an object that contains info about the current Ruins/Foundery planet\n   * @param centerW - represents the coordinates of the current Foundries relative to the game world.\n   * @param radiusW - represents the radius of the Foundries relative to the size of the game world\n   */\n  queueRuins(planet: Planet, centerW: WorldCoords, radiusW: number): void;\n\n  /**\n   * Draws all queued Foundries.\n   */\n  flush(): void;\n}\n\nexport interface AsteroidRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * @param planet - an object that contains info about the current planet the Asteroid is revolving\n   * @param centerW - represents the coordinates of the planet relative to the game world.\n   * @param radiusW - represents the radius of the planet relative to the size of the game world\n   */\n  queueAsteroid(planet: Planet, centerW: CanvasCoords, radiusW: number, color?: RGBVec): void;\n\n  /**\n   * Draws all queued Asteroids.\n   */\n  flush(): void;\n}\n\nexport interface RingRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Rings are used to show the different levels of a planet\n   * @param planet - an object that contains info about the current planet\n   * @param centerW - represents the coordinates of the planet relative to the game world.\n   * @param radiusW - represents the radius of the planet relative to the size of the game world\n   */\n  queueRingAtIdx(\n    planet: Planet,\n    centerW: WorldCoords,\n    radiusW: number,\n    color?: RGBVec,\n    beltIdx?: number,\n    angle?: number\n  ): void;\n\n  /**\n   * Draws all queued Rings.\n   */\n  flush(): void;\n}\n\nexport interface SpriteRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to draw Artifacts onto the screen when around hovering around a planet\n   * @param artifact - an object that contains information on the current Artifact\n   * @param posW - The position of the artifact relative to the game world\n   * @param widthW - The size of the artifact relative to then game world\n   * @param alpha - The opacity of the image of the artifact\n   * @param atFrame\n   * @param color\n   * @param theta - The angle the artifact should be rotated\n   * @param viewport - a GameViewport class\n   */\n  queueArtifactWorld(\n    artifact: RenderedArtifact,\n    posW: CanvasCoords,\n    widthW: number,\n    alpha?: number,\n    atFrame?: number | undefined,\n    color?: RGBVec | undefined,\n    theta?: number | undefined,\n    viewport?: GameViewport\n  ): void;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to draw artifacts when traveling with the voyager\n   * @param artifact - information on the type of artifact\n   * @param pos - the position relative to the canvas\n   * @param width - the width of the artifact relative to the canvas\n   * @param alpha - The opacity of the image of the artifact\n   * @param atFrame\n   * @param color\n   * @param theta - The angle the artifact should be rotated\n   */\n  queueArtifact(\n    artifact: RenderedArtifact,\n    pos: CanvasCoords,\n    width?: number,\n    alpha?: number,\n    atFrame?: number | undefined,\n    color?: RGBVec | undefined,\n    theta?: number | undefined\n  ): void;\n\n  /**\n   * Draws all queued Artifacts.\n   */\n  flush(): void;\n}\n\nexport interface BlackDomainRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Queue the planet that has been dystroyed to be drawn\n   * @param planet - an object that contains info about the current planet\n   * @param centerW - Location of the planet relative to the game world\n   * @param radiusW - Radius of the planet relative to the game world\n   */\n  queueBlackDomain(planet: Planet, centerW: WorldCoords, radiusW: number): void;\n\n  /**\n   * Draws all queued planets with black domain effect.\n   */\n  flush(): void;\n}\n\nexport interface TextRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Queue text to be drawn at world Cooridnates\n   * @param text - The text\n   * @param coords - The coordinates on relative to the game world\n   * @param color - color of the text\n   * @param offY - measured in text units - constant screen-coord offset that it useful for drawing nice things\n   * @param align - how the text should be aligned\n   * @param anchor - How the text should be anchored\n   * @param zIdx - The z axis index of the text\n   */\n  queueTextWorld(\n    text: string,\n    coords: WorldCoords,\n    color?: RGBAVec,\n    offY?: number,\n    align?: TextAlign,\n    anchor?: TextAnchor,\n    zIdx?: number\n  ): void;\n\n  /**\n   * Draws all text in game.\n   */\n  flush(): void;\n}\n\nexport interface VoyageRendererType {\n  rendererType: RendererType;\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Unlike most renderer you will not be given information about voyages.\n   * You can access all voyages by usin GameUIManger.getAllVoyages()\n   */\n  queueVoyages(): void;\n\n  /**\n   * Draws all active voyages.\n   */\n  flush(): void;\n}\n\nexport interface WormholeRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Unlike most renderer you will not be given information about wormholes.\n   * GameUIManager.getUnconfirmedWormholeActivations() to get all unconfirmed wormholes\n   * GameUIManager.getWormholes() to get all active confirmed wormholes\n   */\n  queueWormholes(): void;\n\n  /**\n   * Draws all Wormholes.\n   */\n  flush(): void;\n}\n\nexport interface MineBodyRendererType {\n  rendererType: RendererType;\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Draw the body of the Mine/Asteroid Field\n   * @param planet - Planet class that contains information on the current Mine/Asteroid Field\n   * @param center - The location of the center of the Asteroid Field relative to the game world.\n   * @param radius - Radius of the Asteroid Field relative to the game world\n   * @param z - The amount of Asteroids in the Asteroid field\n   */\n  queueMineScreen(planet: Planet, center: WorldCoords, radius: number, z: number): void;\n\n  /**\n   * Draws all queued mine bodies.\n   */\n  flush(): void;\n\n  setUniforms?(): void;\n}\n\nexport interface BeltRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Draw the Rings around the Mine/Asteroid Field\n   * @param planet - an object that contains info about the Mine/Asteroid Field\n   * @param center - The location of the center of the planet. The coordinate system is determined by the screen arguement.\n   * @param radius - The radius of the planet relative to game world\n   * @param color\n   * @param beltIdx - the index of the belt, the belt with the higher idx is the one rendered on top\n   * @param angle - The angle the belt should be tilted\n   * @param screen - True: coordinates is relative to the canvas False: coordinates are relative to the game world\n   */\n  queueBeltAtIdx(\n    planet: Planet,\n    center: WorldCoords | CanvasCoords,\n    radius?: number,\n    color?: RGBVec,\n    beltIdx?: number,\n    angle?: number,\n    screen?: boolean\n  ): void;\n\n  /**\n   * Draws all queued asteroid field belts.\n   */\n  flush(): void;\n\n  setUniforms?(): void;\n}\n\nexport interface BackgroundRendererType {\n  rendererType: RendererType;\n\n  /**\n   *\n   * @param exploredChunks - an object that contains a alls chunks of space the user has explored\n   * @param highPerfMode - if the game is in high perofromance mode found in settings\n   * @param drawChunkBorders - draws the boarders on each chunk in the game\n   * @param disableFancySpaceEffect - if background renderering should use perlin renderer\n   * @param innerNebulaColor\n   * @param nebulaColor\n   * @param spaceColor\n   * @param deepSpaceColor\n   * @param deadSpaceColor\n   */\n  queueChunks(\n    exploredChunks: Iterable<Chunk>,\n    highPerfMode: boolean,\n    drawChunkBorders: boolean,\n    disableFancySpaceEffect: boolean,\n    innerNebulaColor?: string,\n    nebulaColor?: string,\n    spaceColor?: string,\n    deepSpaceColor?: string,\n    deadSpaceColor?: string\n  ): void;\n\n  /**\n   * Draws the background\n   */\n  flush(): void;\n}\n\nexport interface SpaceRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Called by the game to draw a chunk of the background. A chunk is a square section of the background.\n   * @param chunk a variable that contains information on the chunk being drawn. A chunk is rectangle section of the background\n   */\n  queueChunk(chunk: Chunk): void;\n\n  /**\n   * In the Darkforest settings players can choose to set their own color configuratio for the background. This is called when the color is changed.\n   * @param innerNebulaColor\n   * @param nebulaColor\n   * @param spaceColor\n   * @param deepSpaceColor\n   * @param deadSpaceColor\n   */\n  setColorConfiguration(\n    innerNebulaColor: string,\n    nebulaColor: string,\n    spaceColor: string,\n    deepSpaceColor: string,\n    deadSpaceColor: string\n  ): void;\n\n  /**\n   * Draws all discovered space\n   */\n  flush(): void;\n}\n\nexport interface UnminedRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Called to queue up a chunk of unmined space to be drawn\n   * @param  -param0 the x and y positon on the canvas. The bottom left corner\n   * @param width - the width of the chunk\n   * @param height - the height of the chunk\n   * @param color - optional the color of the chunk\n   * @param zIdx - Z axis\n   */\n  queueRect(\n    { x, y }: CanvasCoords,\n    width: number,\n    height: number,\n    color?: RGBVec,\n    zIdx?: number\n  ): void;\n\n  /**\n   * Draws all undiscovered space\n   */\n  flush(): void;\n}\n\n/**\n * Perlin Renderer is only used when disable fancy space effects is true\n */\nexport interface PerlinRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * @param chunk - a variable that contains information on the chunk being drawn. A chunk is rectangle section of the background.\n   */\n  queueChunk(chunk: Chunk): void;\n\n  /**\n   * Draws all discovered space\n   */\n  flush(): void;\n}\n\nexport interface LineRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * This will affect every line drawn in the game.\n   * Used to draw the line that the voyager take and wormholes\n   * @param start - The coordinates of where the lines start relative to the game world\n   * @param end - The coordinates of where the lines end relative to the game world\n   * @param color\n   * @param width - how thick the line should be from the center\n   * @param zIdx - Z axis\n   * @param dashed - if the line should be dashed\n   */\n  queueLineWorld(\n    start: WorldCoords,\n    end: WorldCoords,\n    color?: RGBAVec,\n    width?: number,\n    zIdx?: number,\n    dashed?: boolean\n  ): void;\n\n  /**\n   * Draws all queued lines\n   */\n  flush(): void;\n}\n\nexport interface RectRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * This will affect every Rectangle drawn in the game.\n   * Drawing the rectangele that shows up when you hover over a planet\n   * @param center - Coordinates of the planet relative to the game world\n   * @param width - Width of planet relative to the game world\n   * @param height - Height of planet relative to the game world\n   * @param color\n   * @param stroke - How thick the border of the rectangle should be\n   * @param zIdx - Z axis\n   */\n  queueRectCenterWorld(\n    center: WorldCoords,\n    width: number,\n    height: number,\n    color?: RGBVec,\n    stroke?: number,\n    zIdx?: number\n  ): void;\n\n  /**\n   * Draws all queued rectangles\n   */\n  flush(): void;\n}\n\nexport interface CircleRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * This will affect every Cricle drawn in the game.\n   * Used for drawing the range a planet can attack\n   * Used for highlighting the destination of a voyage\n   * Used for drawing the world boarder\n   * Used for drawing capture zones\n   * @param center - Center of the circle relative to the canvas\n   * @param radius - Radius relative to the canvas\n   * @param color\n   * @param stroke - How thick the stroke of the circle should be\n   * @param angle - The angle/arc of the cirlce to draw\n   * @param dashed - If the circumference of the circle should be dashed\n   */\n  queueCircleWorld(\n    center: CanvasCoords,\n    radius: number,\n    color?: RGBAVec,\n    stroke?: number,\n    angle?: number,\n    dashed?: boolean\n  ): void;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used for drawing the voyager (circle)\n   * @param center - center of the circle relative to the game world\n   * @param radius - size of the circle relative to the game world\n   * @param color\n   */\n  queueCircleWorldCenterOnly(\n    center: WorldCoords,\n    radius: number, // canvas coords\n    color?: RGBAVec\n  ): void;\n\n  /**\n   * Draws all queued circles\n   */\n  flush(): void;\n}\n\nexport interface UIRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to draw the boarder of the game.\n   */\n  queueBorders(): void;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to draw the range of a planet when it is selected\n   */\n  queueSelectedRangeRing(): void;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to draw a rectangle around a planet to indicate that the planet has been selected\n   */\n  queueSelectedRect(): void;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to draw a rectangle around a planet to indicate that the planet is being hovered over\n   */\n  queueHoveringRect(): void;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to draw the path the mouse is taking when trying to transfer energy\n   */\n  queueMousePath(): void;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to draw the Miner\n   */\n  drawMiner(): void;\n\n  /**\n   * Draws all queued items\n   */\n  flush(): void;\n}\n\nexport interface PlanetRenderManagerType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to draw the range of a planet when it is selected\n   */\n  queueRangeRings(planet: LocatablePlanet): void;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used for Drawing all types of planets\n   * @param cachedPlanets - A Map that contains all planets that have been discovered by the user\n   * @param now - the modular of the current unix time by (2 * pi  * 12000) in seconds\n   * @param highPerfMode - if the game is in high performance mode\n   * @param disableEmojis\n   * @param disableHats\n   */\n  queuePlanets(\n    cachedPlanets: Map<LocationId, PlanetRenderInfo>,\n    now?: number,\n    highPerfMode?: boolean,\n    disableEmojis?: boolean,\n    disableHats?: boolean\n  ): void;\n\n  /**\n   * Draw all queued planets\n   */\n  flush(): void;\n}\n\nexport interface QuasarBodyRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to Draw the body of the Quasar\n   * @param planet - an object that contains info about the current Quasar planet\n   * @param centerW - represents the coordinates of the current Quasar relative to the game world.\n   * @param radiusW - represents the radius of the Quasar relative to the size of the game world.\n   * @param z - z axis\n   * @param angle - the angle the body should be titled\n   */\n  queueQuasarBody(\n    planet: Planet,\n    centerW: WorldCoords,\n    radiusW: number,\n    z?: number,\n    angle?: number\n  ): void;\n\n  /**\n   * Draw all queued Quasar Bodies\n   */\n  flush(): void;\n\n  setUniforms?(): void;\n}\n\nexport interface QuasarRayRendererType {\n  rendererType: RendererType;\n\n  /**\n   * The game calls the queue function when the entities should be put into a back buffer queue.\n   * The back buffer is used to contain information on the entities being drawn for later use in the flush function.\n   * The implementing renderer should contains its own back buffer.\n   * Used to draw the rays on the Quasar.\n   * There are 2 rays one on top and one on the bottom\n   * @param planet - an object that contains info about the current Quasar planet\n   * @param centerW - represents the coordinates of the current Quasar relative to the game world.\n   * @param radiusW - represents the radius of the Quasar relative to the size of the game world.\n   * @param z - z axis\n   * @param top - if the ray is ontop of the Quasar\n   * @param angle - the angle the body should be titled\n   */\n  queueQuasarRay(\n    planet: Planet,\n    centerW: WorldCoords,\n    radiusW: number,\n    z?: number,\n    top?: boolean,\n    angle?: number\n  ): void;\n\n  /**\n   * Draw all queued Quasar Rays\n   */\n  flush(): void;\n\n  setUniforms?(): void;\n}\n\nexport interface CaptureZoneRendererType {\n  rendererType: RendererType;\n\n  /**\n   * Queue all Capture Zones\n   */\n  queueCaptureZones(): void;\n\n  /**\n   * Draw all Capture Zones\n   */\n  flush(): void;\n}\n/**\n * The purpose of this interface is for type checking\n * It make sures that the variable is a type of renderer\n */\nexport interface BaseRenderer {\n  rendererType: RendererType;\n\n  flush(): void;\n}\n\nexport type RendererProgram = {\n  attribs: {\n    [key: string]: AttribProps;\n  };\n  uniforms: {\n    [key: string]: UniformProps;\n  };\n  vertexShader: string;\n  fragmentShader: string;\n};\n"]}