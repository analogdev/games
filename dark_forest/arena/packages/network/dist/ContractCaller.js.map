{"version":3,"file":"ContractCaller.js","sourceRoot":"","sources":["../src/ContractCaller.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,yDAAqE;AAGrE,mDAA4C;AAC5C,yEAA6E;AAE7E;;;;GAIG;AACH,MAAa,cAAc;IAqBzB,YAAmB,KAAa,EAAE,UAAmB;QApBrD;;WAEG;QACc,UAAK,GAAU,IAAI,mDAAwB,CAAC;YAC3D,2BAA2B,EAAE,EAAE;YAC/B,oBAAoB,EAAE,GAAG;YACzB,cAAc,EAAE,EAAE;SACnB,CAAC,CAAC;QAEH;;;WAGG;QACK,eAAU,GAAW,oCAAwB,CAAC;QAQpD,IAAI,KAAK;YAAE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QAC9B,IAAI,UAAU;YAAE,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/C,CAAC;IAED;;;;OAIG;IACI,KAAK,CAAC,QAAQ,CACnB,oBAAyC,EACzC,OAAkB,EAAE;;QAEpB,MAAM,MAAM,GAAG,IAAA,iBAAK,EAClB,KAAK,IAAI,EAAE;;YACT,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;;gBACtC,MAAA,IAAI,CAAC,kBAAkB,0CAAE,iBAAiB,CAAC,CAAC,CAAC,EAAE,EAAE;oBAC/C,CAAC,CAAC,UAAU,EAAE,CAAC;gBACjB,CAAC,CAAC,CAAC;gBACH,OAAO,oBAAoB,CAAC,GAAG,IAAI,CAAC,CAAC;YACvC,CAAC,CAAC,CAAC;YAEH,MAAA,IAAI,CAAC,kBAAkB,0CAAE,iBAAiB,CAAC,CAAC,CAAC,EAAE,EAAE;gBAC/C,CAAC,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;YACrC,CAAC,CAAC,CAAC;YAEH,IAAI;gBACF,MAAM,UAAU,GAAG,MAAM,WAAW,CAAC;gBACrC,MAAA,IAAI,CAAC,kBAAkB,0CAAE,iBAAiB,CAAC,CAAC,CAAC,EAAE,EAAE;oBAC/C,CAAC,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;gBACrC,CAAC,CAAC,CAAC;gBAEH,OAAO,UAAU,CAAC;aACnB;YAAC,OAAO,GAAG,EAAE;gBACZ,IAAgC,GAAI,CAAC,IAAI,KAAK,gBAAgB,EAAE;oBAC9D,MAAM,IAAI,oBAAU,CAAC,2CAA2C,CAAC,CAAC;iBACnE;qBAAM;oBACL,OAAO,CAAC,IAAI,CAAC,qBAAqB,EAAE,GAAG,CAAC,CAAC;oBACzC,MAAM,GAAG,CAAC;iBACX;aACF;QACH,CAAC,EACD,EAAE,OAAO,EAAE,IAAI,CAAC,UAAU,EAAE,CAC7B,CAAC;QAEF,MAAA,IAAI,CAAC,kBAAkB,0CAAE,iBAAiB,CAAC,CAAC,CAAC,EAAE,EAAE;YAC/C,CAAC,CAAC,UAAU,EAAE,CAAC;QACjB,CAAC,CAAC,CAAC;QAEH,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;OAGG;IACI,oBAAoB,CAAC,iBAAqC;QAC/D,IAAI,CAAC,kBAAkB,GAAG,iBAAiB,CAAC;IAC9C,CAAC;CACF;AAjFD,wCAiFC","sourcesContent":["import { DEFAULT_MAX_CALL_RETRIES } from '@darkforest_eth/constants';\nimport { DiagnosticUpdater } from '@darkforest_eth/types';\nimport { ContractFunction } from 'ethers';\nimport retry, { AbortError } from 'p-retry';\nimport { Queue, ThrottledConcurrentQueue } from './ThrottledConcurrentQueue';\n\n/**\n * Instead of allowing the game to call `view` functions on the blockchain directly, all contract\n * calls should go through this class. Its purpose is to throttle the calls to a reasonable rate,\n * and to gracefully handle errors and retries\n */\nexport class ContractCaller {\n  /**\n   * Queue which stores future contract calls.\n   */\n  private readonly queue: Queue = new ThrottledConcurrentQueue({\n    maxInvocationsPerIntervalMs: 10,\n    invocationIntervalMs: 200,\n    maxConcurrency: 20,\n  });\n\n  /**\n   * The maximum amount of times that we want the game to retry any individual call. Retries are\n   * appended to the end of the queue, meaning they respect the throttling settings of this class.\n   */\n  private maxRetries: number = DEFAULT_MAX_CALL_RETRIES;\n\n  /**\n   * Allows us to update the data that might be displayed in the UI.\n   */\n  private diagnosticsUpdater?: DiagnosticUpdater;\n\n  public constructor(queue?: Queue, maxRetries?: number) {\n    if (queue) this.queue = queue;\n    if (maxRetries) this.maxRetries = maxRetries;\n  }\n\n  /**\n   * Submits a call to the call queue. Each call is retried a maximum of\n   * {@link ContractCaller.DEFAULT_MAX_CALL_RETRIES} times. Returns a promise that resolves if the call was\n   * successful, and rejects if it failed even after all the retries.\n   */\n  public async makeCall<T>(\n    contractViewFunction: ContractFunction<T>,\n    args: unknown[] = []\n  ): Promise<T> {\n    const result = retry(\n      async () => {\n        const callPromise = this.queue.add(() => {\n          this.diagnosticsUpdater?.updateDiagnostics((d) => {\n            d.totalCalls++;\n          });\n          return contractViewFunction(...args);\n        });\n\n        this.diagnosticsUpdater?.updateDiagnostics((d) => {\n          d.callsInQueue = this.queue.size();\n        });\n\n        try {\n          const callResult = await callPromise;\n          this.diagnosticsUpdater?.updateDiagnostics((d) => {\n            d.callsInQueue = this.queue.size();\n          });\n\n          return callResult;\n        } catch (err) {\n          if ((<Error & { code?: string }>err).code === 'CALL_EXCEPTION') {\n            throw new AbortError('Could not call function on given contract');\n          } else {\n            console.warn('retrying after err:', err);\n            throw err;\n          }\n        }\n      },\n      { retries: this.maxRetries }\n    );\n\n    this.diagnosticsUpdater?.updateDiagnostics((d) => {\n      d.totalCalls++;\n    });\n\n    return result;\n  }\n\n  /**\n   * Sets the diagnostics updater to the one you provide. If you don't set this, everything apart\n   * from diagnostics continues to function.\n   */\n  public setDiagnosticUpdater(diagnosticUpdater?: DiagnosticUpdater) {\n    this.diagnosticsUpdater = diagnosticUpdater;\n  }\n}\n"]}