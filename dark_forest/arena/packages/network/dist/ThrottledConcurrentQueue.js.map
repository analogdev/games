{"version":3,"file":"ThrottledConcurrentQueue.js","sourceRoot":"","sources":["../src/ThrottledConcurrentQueue.ts"],"names":[],"mappings":"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","sourcesContent":["import { findIndex } from 'lodash';\nimport CircularBuffer from 'mnemonist/circular-buffer';\nimport deferred from 'p-defer';\n\n/**\n * Represents a task that has been queued for later execution.\n */\ninterface QueuedTask<T, U> {\n  /**\n   * This is called when the task succeeds.\n   */\n  resolve: (t: T) => void;\n\n  /**\n   * This is called when the task fails.\n   */\n  reject: (e: Error | undefined) => void;\n\n  /**\n   * Starts the task.\n   */\n  start: () => Promise<T>;\n\n  /**\n   * Optional data to be associated with the task.\n   * Currently only used when finding a task during removal.\n   */\n  metadata: U | undefined;\n}\n\n/**\n * Let's keep things flexible by keeping this type small.\n */\nexport interface Queue {\n  add<T>(start: () => Promise<T>): Promise<T>;\n  size: () => number;\n}\n\nexport interface ConcurrentQueueConfiguration {\n  maxInvocationsPerIntervalMs: number;\n  invocationIntervalMs: number;\n  maxConcurrency?: number;\n}\n\n/**\n * A queue that executes promises with a max throughput, and optionally max\n * concurrency.\n */\nexport class ThrottledConcurrentQueue<U = unknown> implements Queue {\n  /**\n   * The interval during which we only allow a certain maximum amount of tasks\n   * to be executed.\n   */\n  private readonly invocationIntervalMs: number;\n\n  /**\n   * Maximum amount of tasks that can be executing at the same time.\n   */\n  private readonly maxConcurrency: number;\n\n  /**\n   * Queue of tasks to execute. Added to the front, popped off the back.\n   */\n  private taskQueue: Array<QueuedTask<unknown, U>> = [];\n\n  /**\n   * Each time a task is executed, record the start of its execution time.\n   * Execution timestamps are removed when they become outdated. Used for\n   * keeping the amount of executions under the throttle limit.\n   */\n  private executionTimestamps: CircularBuffer<number>;\n\n  /**\n   * Amount of tasks being executed right now.\n   */\n  private concurrency = 0;\n\n  /**\n   * When we schedule an attempt at executing another task in the future,\n   * we don't want to schedule it more than once. Therefore, we keep track\n   * of this scheduled attempt.\n   */\n  private executionTimeout: ReturnType<typeof setTimeout> | undefined;\n\n  public constructor(config: ConcurrentQueueConfiguration) {\n    this.invocationIntervalMs = config.invocationIntervalMs;\n    this.maxConcurrency = config.maxConcurrency ?? Number.POSITIVE_INFINITY;\n    this.executionTimestamps = new CircularBuffer(Array, config.maxInvocationsPerIntervalMs);\n\n    if (config.maxInvocationsPerIntervalMs <= 0) {\n      throw new Error('must allow at least one invocation per interval');\n    }\n\n    if (this.invocationIntervalMs <= 0) {\n      throw new Error('invocation interval must be positive');\n    }\n\n    if (this.maxConcurrency <= 0) {\n      throw new Error('max concurrency must be positive');\n    }\n  }\n\n  /**\n   * Adds a task to be executed at some point in the future. Returns a promise that resolves when\n   * the task finishes successfully, and rejects when there is an error.\n   *\n   * @param start a function that returns a promise representing the task\n   * @param metadata optional data to be associated with the task\n   */\n  public add<T>(start: () => Promise<T>, metadata?: U): Promise<T> {\n    const { resolve, reject, promise } = deferred<T>();\n\n    this.taskQueue.unshift({\n      resolve: resolve as (t: unknown) => void,\n      reject,\n      start,\n      metadata,\n    });\n\n    setTimeout(() => {\n      this.executeNextTasks();\n    }, 0);\n\n    return promise;\n  }\n\n  /**\n   * Remove one task from the queue. For this to work, you have to provide\n   * the optional metadata during queue construction and addition of tasks.\n   *\n   * Throws an error if no matching task is found.\n   * @param predicate Should return true for the task you would like removed.\n   */\n  public remove(predicate: (metadata: U | undefined) => boolean): QueuedTask<unknown, U> {\n    const foundIndex = findIndex(this.taskQueue, (task: QueuedTask<unknown, U>) =>\n      predicate(task.metadata)\n    );\n\n    if (foundIndex === -1) throw new Error(`specified task was not found`);\n\n    return this.taskQueue.splice(foundIndex, 1)[0];\n  }\n\n  /**\n   * Prioritize a currently queued task so that it is up next for execution.\n   * For this to work, you have to provide the optional metadata during\n   * queue construction and addition of tasks.\n   *\n   * Prioritized tasks are executed in FILO order.\n   *\n   * Throws an error if no matching task is found.\n   * @param predicate Should return true for the task you would like prioritized.\n   */\n  public prioritize(predicate: (metadata: U | undefined) => boolean): QueuedTask<unknown, U> {\n    const foundIndex = findIndex(this.taskQueue, (task: QueuedTask<unknown, U>) =>\n      predicate(task.metadata)\n    );\n\n    if (foundIndex === -1) throw new Error(`specified task was not found`);\n\n    const foundTask = this.taskQueue.splice(foundIndex, 1)[0];\n    this.taskQueue.push(foundTask);\n\n    return foundTask;\n  }\n\n  /**\n   * Returns the amount of queued items, not including the ones that are being executed at this\n   * moment.\n   */\n  public size() {\n    return this.taskQueue.length;\n  }\n\n  /**\n   * Runs tasks until it's at either the throttle or concurrency limit. If there are more tasks to\n   * be executed after that, schedules itself to execute again at the soonest possible moment.\n   */\n  private async executeNextTasks(): Promise<void> {\n    this.deleteOutdatedExecutionTimestamps();\n\n    const tasksToExecute = Math.min(\n      this.throttleQuotaRemaining(),\n      this.concurrencyQuotaRemaining(),\n      this.taskQueue.length\n    );\n\n    for (let i = 0; i < tasksToExecute; i++) {\n      this.next().then(this.executeNextTasks.bind(this));\n    }\n\n    const nextPossibleExecution = this.nextPossibleExecution();\n\n    if (this.taskQueue.length > 0 && nextPossibleExecution) {\n      if (this.executionTimeout) {\n        clearTimeout(this.executionTimeout);\n      }\n\n      this.executionTimeout = setTimeout(this.executeNextTasks.bind(this), nextPossibleExecution);\n    }\n  }\n\n  /**\n   * Returns the soonest possible time from now we could execute another task without going over the\n   * throttle limit.\n   */\n  private nextPossibleExecution(): number | undefined {\n    const oldestExecution = this.executionTimestamps.peekFirst();\n\n    if (!oldestExecution || this.concurrencyQuotaRemaining() === 0) {\n      return undefined;\n    }\n\n    return Date.now() - oldestExecution + this.invocationIntervalMs;\n  }\n\n  /**\n   * At this moment, how many more tasks we could execute without exceeding the concurrency quota.\n   */\n  private concurrencyQuotaRemaining(): number {\n    return this.maxConcurrency - this.concurrency;\n  }\n\n  /**\n   * At this moment, how many more tasks we could execute without exceeding the throttle quota.\n   */\n  private throttleQuotaRemaining(): number {\n    return this.executionTimestamps.capacity - this.executionTimestamps.size;\n  }\n\n  /**\n   * Removes all task execution timestamps that are older than [[this.invocationIntervalMs]],\n   * because those invocations have no bearing on whether or not we can execute another task.\n   */\n  private deleteOutdatedExecutionTimestamps() {\n    const now = Date.now();\n\n    let oldestInvocation = this.executionTimestamps.peekFirst();\n\n    while (oldestInvocation && oldestInvocation < now - this.invocationIntervalMs) {\n      this.executionTimestamps.shift();\n      oldestInvocation = this.executionTimestamps.peekFirst();\n    }\n  }\n\n  /**\n   * If there is a next task to execute, executes it. Records the time of execution in\n   * [[executionTimestamps]]. Increments and decrements concurrency counter. Neither throttles nor\n   * limits concurrency.\n   */\n  private async next(): Promise<void> {\n    const task = this.taskQueue.pop();\n\n    if (!task) {\n      return;\n    }\n\n    this.executionTimestamps.push(Date.now());\n    this.concurrency++;\n\n    try {\n      task.resolve(await task.start());\n    } catch (e) {\n      task.reject(e as Error);\n    }\n\n    this.concurrency--;\n  }\n}\n"]}