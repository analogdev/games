{"version":3,"file":"fakeHash.js","sourceRoot":"","sources":["../src/fakeHash.ts"],"names":[],"mappings":"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","sourcesContent":["import bigInt from 'big-integer';\n\n/**\n * Generate a random number based on some seed. Useful for procedural generation.\n *\n * @param seed The seed of the random number.\n */\nexport function seededRandom(seed: number) {\n  const x = Math.sin(seed) * 10000;\n  return x - Math.floor(x);\n}\n\ntype IdxWithRand = {\n  idx: number;\n  rand: number;\n};\n\nconst SIZE = 65536; // we permute 256x256 grids of 256x256 mega-chunks\nlet globalSeed = 1;\n\nconst globalRandom = () => {\n  return seededRandom(globalSeed++);\n};\n\nconst arr: IdxWithRand[] = [];\nfor (let i = 0; i < SIZE; i += 1) {\n  arr.push({\n    idx: i,\n    rand: globalRandom(),\n  });\n}\narr.sort((a, b) => a.rand - b.rand);\nconst lookup = arr.map((a) => a.idx);\nconst lookupInv = Array(SIZE).fill(0);\nfor (let i = 0; i < SIZE; i += 1) {\n  lookupInv[lookup[i]] = i;\n}\n\n// return the number in [0, n) congruent to m (mod n)\nconst posMod = (m: number, n: number) => {\n  const val = Math.floor(m / n) * n;\n  return m - val;\n};\n\n// permutation by lookup table\nconst sigma = (x: number, y: number) => {\n  const val = 256 * x + y;\n  const idx = posMod(val, SIZE);\n  const ret: [number, number] = [Math.floor(lookup[idx] / 256), lookup[idx] % 256];\n  return ret;\n};\n\n// cyclic permutation\nconst cyc = (m: number, n: number) => (r: number, s: number) => {\n  const val = posMod(256 * (r + m) + (s + n), SIZE);\n  const ret: [number, number] = [Math.floor(val / 256), val % 256];\n  return ret;\n};\n\n// 4/65536 in a 256x256 square are valid planets\n// then generate the rest of the string pseudorandomly\n/**\n * @hidden\n */\nexport const fakeHash = (planetRarity: number) => (x: number, y: number) => {\n  const m = Math.floor(x / 256);\n  const r = x - m * 256;\n  const n = Math.floor(y / 256);\n  const s = y - n * 256;\n  const [mPrime, nPrime] = sigma(m, n);\n  const [xPrime, yPrime] = sigma(...cyc(mPrime, nPrime)(...sigma(r, s)));\n  const validPlanet = xPrime * 256 + yPrime < (256 * 256) / planetRarity;\n  // first four bytes\n  let hash = validPlanet ? '00000000' : '1eadbeef';\n  // next 28 bytes, generated 4 at a time. deterministically generated from x, y\n  const seed = 8 * (10000000 * x + y);\n  for (let i = 0; i < 7; i += 1) {\n    const rand = Math.floor(seededRandom(seed + i) * 2 ** 32);\n    let append = rand.toString(16);\n    while (append.length < 8) {\n      append = '0' + append;\n    }\n    hash += append;\n  }\n  return bigInt(hash, 16);\n};\n"]}