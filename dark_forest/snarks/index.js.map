{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;;;AAoMH;;;;;;;;GAQG;AACH,SAAgB,qBAAqB,CACnC,UAAwB,EACxB,aAAuB;IAEvB,8GAA8G;IAC9G,cAAc;IACd,OAAO;QACL,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;QAC3B,8DAA8D;QAC9D,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;QAC9E,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;QAC3B,aAAa,EAAE,QAAQ;KACJ,CAAC;AACxB,CAAC;AAbD,sDAaC;AAED,kFAAkF;AAClF;;GAEG;AACH,SAAgB,SAAS,CAAC,gBAA0B,EAAE;IACpD,OAAO;QACL,KAAK,EAAE;YACL,IAAI,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;YACrB,IAAI,EAAE;gBACJ,CAAC,GAAG,EAAE,GAAG,CAAC;gBACV,CAAC,GAAG,EAAE,GAAG,CAAC;gBACV,CAAC,GAAG,EAAE,GAAG,CAAC;aACX;YACD,IAAI,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;SACtB;QACD,aAAa,EAAE,aAAa;KAC7B,CAAC;AACJ,CAAC;AAbD,8BAaC;AAED,gFAAgF;AAChF;;GAEG;AACU,QAAA,mBAAmB,GAAG,OAAO,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;AAEpE;;GAEG;AACU,QAAA,mBAAmB,GAAG,OAAO,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;AAEpE;;GAEG;AACU,QAAA,iBAAiB,GAAG,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;AAEhE;;GAEG;AACU,QAAA,iBAAiB,GAAG,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;AAEhE;;GAEG;AACU,QAAA,iBAAiB,GAAG,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;AAEhE;;GAEG;AACU,QAAA,iBAAiB,GAAG,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;AAEhE;;GAEG;AACU,QAAA,sBAAsB,GAAG,OAAO,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;AAE1E;;GAEG;AACU,QAAA,sBAAsB,GAAG,OAAO,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;AAE1E;;GAEG;AACU,QAAA,sBAAsB,GAAG,OAAO,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;AAE1E;;GAEG;AACU,QAAA,sBAAsB,GAAG,OAAO,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC","sourcesContent":["/**\n * This package contains `.wasm` compiled SNARK circuits and `.zkey`\n * proving/verifier keys for the Dark Forest SNARKs. It also contains typescript\n * types for inputs and outputs to the SnarkJS functions we use to calculate\n * Dark Forest SNARK proofs, as well as conversion methods that convert between\n * SnarkJS outputs and Dark Forest contract call args.\n *\n * ## Installation\n *\n * You can install this package using [`npm`](https://www.npmjs.com) or\n * [`yarn`](https://classic.yarnpkg.com/lang/en/) by running:\n *\n * ```bash\n * npm install --save @darkforest_eth/snarks\n * ```\n * ```bash\n * yarn add @darkforest_eth/snarks\n * ```\n *\n * When using this in a plugin, you might want to load it with [skypack](https://www.skypack.dev)\n *\n * ```js\n * import * as snarks from 'http://cdn.skypack.dev/@darkforest_eth/snarks'\n * ```\n *\n * @packageDocumentation\n */\n\n/**\n * Shape of a javascript object that must be passed into snarkJS `fullProve`\n * proof generation function for `reveal` circuit\n */\nexport interface RevealSnarkInput {\n  x: string;\n  y: string;\n  PLANETHASH_KEY: string;\n  SPACETYPE_KEY: string;\n  SCALE: string;\n  xMirror: string;\n  yMirror: string;\n}\n\n/**\n * Shape of the args for `revealLocation` DarkForest contract call\n */\nexport type RevealSnarkContractCallArgs = [\n  [string, string], // proofA\n  [\n    // proofB\n    [string, string],\n    [string, string]\n  ],\n  [string, string], // proofC\n  [string, string, string, string, string, string, string, string, string] // locationId (BigInt), perlin, x (BigInt mod p), y (BigInt mod p), planetHashKey, spaceTypeKey, perlin lengthscale, perlin xmirror, perlin ymirror\n];\n\n/**\n * Shape of a javascript object that must be passed into snarkJS `fullProve`\n * proof generation function for `init` circuit\n */\nexport interface InitSnarkInput {\n  x: string;\n  y: string;\n  r: string;\n  PLANETHASH_KEY: string;\n  SPACETYPE_KEY: string;\n  SCALE: string;\n  xMirror: string;\n  yMirror: string;\n}\n\n/**\n * Shape of the args for the `initializePlayer` DarkForest contract call\n */\nexport type InitSnarkContractCallArgs = [\n  [string, string], // proofA\n  [\n    // proofB\n    [string, string],\n    [string, string]\n  ],\n  [string, string], // proofC\n  [string, string, string, string, string, string, string, string] // locationId (BigInt), perlin, radius, planetHashKey, spaceTypeKey, perlin lengthscale, perlin xmirror, perlin ymirror\n];\n\n/**\n * Shape of a javascript object that must be passed into snarkJS `fullProve`\n * proof generation function for `move` circuit\n */\nexport interface MoveSnarkInput {\n  x1: string;\n  y1: string;\n  x2: string;\n  y2: string;\n  r: string;\n  distMax: string;\n  PLANETHASH_KEY: string;\n  SPACETYPE_KEY: string;\n  SCALE: string;\n  xMirror: string;\n  yMirror: string;\n}\n\n/**\n * (Almost) shape of the args for `move` DarkForest contract call.\n * The fourth array element additionally needs shipsMoved, silverMoved, and\n * artifactIdMoved before it can be passed as args to `move`, but those values\n * are not part of the zkSNARK.\n */\nexport type MoveSnarkContractCallArgs = [\n  [string, string], // proofA\n  [\n    // proofB\n    [string, string],\n    [string, string]\n  ],\n  [string, string], // proofC\n  [\n    string, // from locationID (BigInt)\n    string, // to locationID (BigInt)\n    string, // perlin at to\n    string, // radius at to\n    string, // distMax\n    string, // planetHashKey\n    string, // spaceTypeKey\n    string, // perlin lengthscale\n    string, // perlin xmirror (1 true, 0 false)\n    string // perlin ymirror (1 true, 0 false)\n  ]\n];\n\n/**\n * Shape of a javascript object that must be passed into snarkJS `fullProve`\n * proof generation function for `biomebase` circuit\n */\nexport interface BiomebaseSnarkInput {\n  x: string;\n  y: string;\n  PLANETHASH_KEY: string;\n  BIOMEBASE_KEY: string;\n  SCALE: string;\n  xMirror: string;\n  yMirror: string;\n}\n\n/**\n * Shape of the args for `findArtifact` DarkForest contract call.\n */\nexport type BiomebaseSnarkContractCallArgs = [\n  [string, string], // proofA\n  [\n    // proofB\n    [string, string],\n    [string, string]\n  ],\n  [string, string], // proofC\n  [\n    string, // hash\n    string, // biomebase\n    string, // planethash key\n    string, // biomebase key\n    string, // perlin lengthscale\n    string, // perlin xmirror (1 true, 0 false)\n    string // perlin ymirror (1 true, 0 false)\n  ]\n];\n\n/**\n * Shape of a javascript object that must be passed into snarkJS `fullProve`\n * proof generation function for `whitelist` circuit\n */\nexport interface WhitelistSnarkInput {\n  key: string;\n  recipient: string;\n}\n\n/**\n * Shape of the args for `whitelistRegister` DarkForest contract call.\n */\nexport type WhitelistSnarkContractCallArgs = [\n  [string, string], // proofA\n  [\n    // proofB\n    [string, string],\n    [string, string]\n  ],\n  [string, string], // proofC\n  [\n    string, // hashed whitelist key\n    string // recipient address\n  ]\n];\n\n/**\n * Type representing the shape of args that are passed into DarkForest\n * functions that require zkSNARK verification.\n */\nexport type ContractCallArgs =\n  | RevealSnarkContractCallArgs\n  | InitSnarkContractCallArgs\n  | MoveSnarkContractCallArgs\n  | BiomebaseSnarkContractCallArgs\n  | WhitelistSnarkContractCallArgs;\n\n/**\n * A zkSNARK proof (without signals) generated by snarkJS `fullProve`\n */\nexport interface SnarkJSProof {\n  pi_a: [string, string, string];\n  pi_b: [[string, string], [string, string], [string, string]];\n  pi_c: [string, string, string];\n}\n\n/**\n * A zkSNARK proof and corresponding public signals generated by snarkJS\n * `fullProve`\n */\nexport interface SnarkJSProofAndSignals {\n  proof: SnarkJSProof;\n  publicSignals: string[];\n}\n\n/**\n * Method for converting the output of snarkJS `fullProve` into args that can be\n * passed into DarkForest smart contract functions which perform zk proof\n * verification.\n *\n * @param snarkProof the SNARK proof\n * @param publicSignals the circuit's public signals (i.e. output signals and\n * public input signals)\n */\nexport function buildContractCallArgs(\n  snarkProof: SnarkJSProof,\n  publicSignals: string[]\n): ContractCallArgs {\n  // the object returned by genZKSnarkProof needs to be massaged into a set of parameters the verifying contract\n  // will accept\n  return [\n    snarkProof.pi_a.slice(0, 2), // pi_a\n    // genZKSnarkProof reverses values in the inner arrays of pi_b\n    [snarkProof.pi_b[0].slice(0).reverse(), snarkProof.pi_b[1].slice(0).reverse()], // pi_b\n    snarkProof.pi_c.slice(0, 2), // pi_c\n    publicSignals, // input\n  ] as ContractCallArgs;\n}\n\n// if we're using a mock hash and ZK proofs are disabled, just give an empty proof\n/**\n * @hidden\n */\nexport function fakeProof(publicSignals: string[] = []): SnarkJSProofAndSignals {\n  return {\n    proof: {\n      pi_a: ['0', '0', '0'],\n      pi_b: [\n        ['0', '0'],\n        ['0', '0'],\n        ['0', '0'],\n      ],\n      pi_c: ['0', '0', '0'],\n    },\n    publicSignals: publicSignals,\n  };\n}\n\n// These paths are only useful for Node.js since they are absolute on the system\n/**\n * @hidden\n */\nexport const revealSnarkWasmPath = require.resolve('./reveal.wasm');\n\n/**\n * @hidden\n */\nexport const revealSnarkZkeyPath = require.resolve('./reveal.zkey');\n\n/**\n * @hidden\n */\nexport const initSnarkWasmPath = require.resolve('./init.wasm');\n\n/**\n * @hidden\n */\nexport const initSnarkZkeyPath = require.resolve('./init.zkey');\n\n/**\n * @hidden\n */\nexport const moveSnarkWasmPath = require.resolve('./move.wasm');\n\n/**\n * @hidden\n */\nexport const moveSnarkZkeyPath = require.resolve('./move.zkey');\n\n/**\n * @hidden\n */\nexport const biomebaseSnarkWasmPath = require.resolve('./biomebase.wasm');\n\n/**\n * @hidden\n */\nexport const biomebaseSnarkZkeyPath = require.resolve('./biomebase.zkey');\n\n/**\n * @hidden\n */\nexport const whitelistSnarkWasmPath = require.resolve('./whitelist.wasm');\n\n/**\n * @hidden\n */\nexport const whitelistSnarkZkeyPath = require.resolve('./whitelist.zkey');\n"]}